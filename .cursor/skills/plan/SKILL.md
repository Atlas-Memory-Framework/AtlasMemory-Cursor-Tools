---
name: plan
description: Orchestrate the /plan workflow to create or update the current plan artifact (autonamed by Cursor) as the design SSOT and implementation plan. Use when the user runs /plan, asks to create a plan, or wants to progress planning stages with validation and reviews.
---

# /plan Orchestrator

## Purpose
Create or update the current plan artifact (Cursor autonames plan files) and move it through Context, Feature, Technical, Implementation, and Planning Reviews with deterministic validators and decision logging.

## Core rules
- The SSOT is the current plan artifact; do not assume a fixed filename.
- If a plan doc is present in the thread context, ALWAYS treat that as the SSOT for this session.
- Only if no in-thread plan artifact exists, fall back to creating a new plan doc from `reference.md`.
- Do not rely on repo-local plan folders (e.g. `.cursor/plans/`) as a source of truth; they may not exist or be populated.
- The Plan State block is strict and machine-checkable. Keep it structured.
- Maintain Plan State hygiene:
  - Ensure `PlanFormatVersion` is present (default to `1` when creating a new plan).
  - Ensure `PlanTier` is set (`Full` by default; use `Lite` only when clearly low-risk/small-scope).
  - Keep `BaseBranch`, `BaseCommit`, and `TargetBranch` populated when known to reduce drift.
- Workflow order is fixed: Context -> Feature -> Technical -> Implementation -> Reviews.
- Navigation is flexible: if a gate fails, route back to the failing section and patch.
- Make the smallest patch that advances the current gate.
- Do not implement code during /plan.
- Decision boundaries require A/B/C options and a Decision Log entry.
- /plan does not auto re-run; it advances only on explicit user invocation.
- If the plan is blocked on a user decision, record it in the Plan State block and do not advance stages until resolved.

## Plan tiering (Lite vs Full)
- `PlanTier` controls strictness. Do not let "Full requirements" slow down truly small changes, and do not let "Lite" hide risk.
- Default to `Full` unless the change is clearly small and low-risk.
- If you set `PlanTier: Lite`, ensure the plan still contains:
  - Goals/Non-Goals + Evaluation Criteria + NFRs (can be brief)
  - Owned file deltas and explicit rollback
  - A minimal test matrix (what risk is tested, and how)
  - Planning Reviews section filled using required schemas (may be brief)

## Cursor UI notes
- Cursor may store the plan doc in the conversation context with an autogenerated filename.
- When that happens, treat the in-thread plan as the SSOT for this session.
- Persist updates into the same plan artifact; do not fork unless the user requests a new plan.

## On each /plan invocation
1. Load the current plan artifact from thread context.
2. If missing, create a new plan doc using the template in `reference.md`.
3. Determine `CurrentStage`.
4. Run validators in stage order up to the current stage.
5. Route to the first failing gate and patch that section.
6. Re-run the affected validator.
7. Advance stage only when its gate passes.
8. If further progress is needed, ask the user to run /plan again.

## Validators (deterministic)
- ContextAlignment: user labels summary Accurate/Mostly/Wrong; handle accepted unknowns with DR refs.
- FeatureClarity: evaluation criteria, assumptions/tests, ranked risks with status, alternatives rejected, >=1 failure mode.
- TechnicalClarity: integration points named, failure modes per integration point, risks/assumptions updated, invariants/SSOTs respected.
- PlanReadiness:
  - file deltas are exhaustive and include an explicit owner (WS/agent) and rationale
  - workstreams include dependencies, merge points, and owned files
  - workstream file ownership is consistent (each file delta has exactly one owner until an explicit merge point)
  - integration / merge points checklist exists
  - phases/tasks map to owners and include evidence-based exit criteria
  - test plan includes at least a minimal test matrix
  - rollout includes explicit rollback steps
- PlanningReviewsComplete: required reviews done with dispositions logged; expert-tech either done or N/A with rationale.

## Sub-skills used
- `/context-ingestion`
- `/challenge-loop mode=ideation`
- `/feature-doc-writer`
- `/technical-planning`
- `/challenge-loop mode=technical`
- `/implementation-planning`
- `/planning-reviews`

## Decision boundary enforcement
If multiple viable options exist and the choice changes architecture or execution:
- present A/B/C options with pros/cons
- require explicit user choice or explicit risk acceptance
- log a DR entry
- do not advance stages without that decision

## Accepted unknowns discipline
When an unknown is accepted:
- record an explicit impact radius (what could be affected)
- record a tripwire (what signal during build should force a plan patch)
- always include a DR reference

## Output
- Patch the current plan artifact only.
- Reply with a short summary of changes, gate status, and any required user decision.

## Additional resources
- Plan template: [reference.md](reference.md)
