---
name: plan
description: Orchestrate the /plan workflow to create or update the current plan artifact (autonamed by Cursor) as the design SSOT and implementation plan. Use when the user runs /plan, asks to create a plan, or wants to progress planning stages with validation and reviews.
---

# /plan Orchestrator

## Purpose
Create or update the current plan artifact (Cursor autonames plan files) and move it through Context, Feature, Technical, Implementation, and Planning Reviews with deterministic validators and decision logging.

## Core rules
- The SSOT is the current plan artifact; do not assume a fixed filename.
- If a plan doc is present in the thread context, ALWAYS treat that as the SSOT for this session.
- Only if no in-thread plan artifact exists, fall back to creating a new plan doc from `reference.md`.
- Do not rely on repo-local plan folders (e.g. `.cursor/plans/`) as a source of truth; they may not exist or be populated.
- The Plan State block is strict and machine-checkable. Keep it structured.
- Workflow order is fixed: Context -> Feature -> Technical -> Implementation -> Reviews.
- Navigation is flexible: if a gate fails, route back to the failing section and patch.
- Make the smallest patch that advances the current gate.
- Do not implement code during /plan.
- Decision boundaries require A/B/C options and a Decision Log entry.
- /plan does not auto re-run; it advances only on explicit user invocation.
- If the plan is blocked on a user decision, record it in the Plan State block and do not advance stages until resolved.

## Cursor UI notes
- Cursor may store the plan doc in the conversation context with an autogenerated filename.
- When that happens, treat the in-thread plan as the SSOT for this session.
- Persist updates into the same plan artifact; do not fork unless the user requests a new plan.

## On each /plan invocation
1. Load the current plan artifact from thread context.
2. If missing, create a new plan doc using the template in `reference.md`.
3. Determine `CurrentStage`.
4. Run validators in stage order up to the current stage.
5. Route to the first failing gate and patch that section.
6. Re-run the affected validator.
7. Advance stage only when its gate passes.
8. If further progress is needed, ask the user to run /plan again.

## Validators (deterministic)
- ContextAlignment: user labels summary Accurate/Mostly/Wrong; handle accepted unknowns with DR refs.
- FeatureClarity: evaluation criteria, assumptions/tests, ranked risks with status, alternatives rejected, >=1 failure mode.
- TechnicalClarity: integration points named, failure modes per integration point, risks/assumptions updated, invariants/SSOTs respected.
- PlanReadiness: exhaustive file deltas + rationale; workstreams + dependencies + merge points; phases/tasks + evidence exit criteria; test plan + rollout.
- PlanningReviewsComplete: required reviews done with dispositions logged; expert-tech either done or N/A with rationale.

## Sub-skills used
- `/context-ingestion`
- `/challenge-loop mode=ideation`
- `/feature-doc-writer`
- `/technical-planning`
- `/challenge-loop mode=technical`
- `/implementation-planning`
- `/planning-reviews`

## Decision boundary enforcement
If multiple viable options exist and the choice changes architecture or execution:
- present A/B/C options with pros/cons
- require explicit user choice or explicit risk acceptance
- log a DR entry
- do not advance stages without that decision

## Output
- Patch the current plan artifact only.
- Reply with a short summary of changes, gate status, and any required user decision.

## Additional resources
- Plan template: [reference.md](reference.md)
